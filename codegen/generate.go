package main

import (
	"encoding/json"
	"fmt"
	"github.com/skamensky/skam.dev/codegen/sources/common_utils"
	"gopkg.in/yaml.v3"
	"os"
	"path"
	"strings"
)

type Config struct {
	Name    string     `json:"name"`
	Type    string     `json:"type"`
	Sources []string   `json:"sources"`
	Targets [][]string `json:"targets"`
}

var ONE_OFFS = map[string]func(c *Config){
	"docker_compose_environments": generateDevComposeFile,
	"nginx_environments":          generateNginxDev,
}

func generateNginxDev(c *Config) {
	nginxProd, err := os.ReadFile(path.Join(c.Sources...))

	if err != nil {
		panic(err)
	}

	nginxDev := "# DO NOT EDIT. Autogenerated by codegen/generate.go\n"
	currentlyIgnoring := false
	for _, line := range strings.Split(string(nginxProd), "\n") {
		if strings.Contains(line, "#dev-") {
			if strings.Contains(line, "#dev-remove-end") {
				currentlyIgnoring = false
			}
			if strings.Contains(line, "#dev-remove-start") {
				currentlyIgnoring = true
			}
			if strings.Contains(line, "dev-replace=") {
				rhs := strings.Split(line, "dev-replace=")[1]
				nginxDev += rhs + "\n"
			}
		} else if !currentlyIgnoring {
			nginxDev += line + "\n"
		}
	}
	err = os.WriteFile(c.targetDirectroriesQualified()[0], []byte(nginxDev), 0644)
	if err != nil {
		panic(err)
	}
}

func generateDevComposeFile(c *Config) {

	// struct definitions generated from here https://zhwt.github.io/yaml-to-go/
	// needs to be updated if the yaml file changes
	data, err := os.ReadFile("docker-compose-prod.yaml")
	if err != nil {
		panic(err)
	}

	container := make(map[interface{}]interface{})

	err = yaml.Unmarshal(data, &container)
	if err != nil {
		panic(err)
	}

	sourceToTargets := make(map[string][]string)
	for index, source := range c.Sources {
		for _, target := range c.Targets[index] {
			sourceToTargets[source] = append(sourceToTargets[source], target)
		}
	}

	serviceNameToHostVolume := make(map[string]map[string]interface{})
	services := container["services"].(map[string]interface{})
	for serviceName, service := range services {
		if _, ok := sourceToTargets[serviceName]; ok {
			serviceT := service.(map[string]interface{})
			contextDir := serviceT["build"].(map[string]interface{})["context"]
			newVolume := make(map[string]interface{})
			newVolume["type"] = "bind"
			newVolume["source"] = contextDir
			newVolume["target"] = path.Join("/mnt/host/", contextDir.(string))
			serviceNameToHostVolume[serviceName] = newVolume
		}
	}

	for source, targets := range sourceToTargets {
		for _, target := range targets {
			sourceConfig := services[source].(map[string]interface{})
			targetVolume := serviceNameToHostVolume[target]
			sourceConfig["volumes"] = append(sourceConfig["volumes"].([]interface{}), targetVolume)
		}
	}

	devCompose, err := yaml.Marshal(container)
	if err != nil {
		panic(err)
	}

	err = os.WriteFile("docker-compose-dev.yaml", devCompose, 0644)

	if err != nil {
		panic(err)
	}

}

func (c *Config) targetDirectroriesQualified() []string {
	qualified := []string{}
	for _, targetDirectory := range c.Targets {
		qualified = append(qualified, path.Join(targetDirectory...))
	}
	return qualified
}

func (c *Config) sourceQualified() string {
	return path.Join("codegen", "sources", c.Sources[0])
}

func findClosestModFile(sourcePath string) string {
	limit := 10
	currPath := sourcePath
	for i := 1; i < limit; i++ {
		entries, err := os.ReadDir(currPath)
		if err != nil {
			panic(err)
		}
		for _, entry := range entries {
			if entry.Name() == "go.mod" {
				return path.Join(currPath, "go.mod")
			}

		}
		currPath = path.Dir(currPath)
	}
	panic(fmt.Errorf("Could not find go.mod file in %v", sourcePath))
}

func (c *Config) Generate() {
	switch c.Type {
	case "proto":
		for _, targetDirectory := range c.targetDirectroriesQualified() {
			targetDirWithName := path.Join(targetDirectory, c.Name)
			err := os.MkdirAll(targetDirWithName, 0755)
			if err != nil {
				panic(err)
			}
			args := []string{
				"--go_out=" + targetDirWithName,
				"--go-grpc_out=" + targetDirWithName,
				c.sourceQualified(),
			}
			res := common_utils.NewCommand("protoc", args).WithVerbose().WithTreatStderrAsErr().Run()

			if res.Err != nil {
				panic(res.Err)
			}
			closestModule := path.Dir(findClosestModFile(targetDirWithName))
			res = common_utils.NewCommand("go", []string{"mod", "tidy"}).WithVerbose().WithTreatStderrAsErr().WithDir(closestModule).Run()

		}
	case "raw_source":
		for _, targetDirectory := range c.targetDirectroriesQualified() {
			err := os.MkdirAll(targetDirectory, 0755)
			if err != nil {
				panic(err)
			}
			res := common_utils.NewCommand("cp", []string{"--recursive", c.sourceQualified(), targetDirectory}).WithVerbose().WithTreatStderrAsErr().Run()
			if res.Err != nil {
				panic(res.Err)
			}
		}
	case "one_off":
		gen_func, ok := ONE_OFFS[c.Name]
		if !ok {
			panic(fmt.Errorf("One off %v not found", c.Name))
		}
		gen_func(c)
	default:
		panic("Unsupported  config source: " + c.Sources[0])
	}
}

func RunningFromRepoRoot() bool {
	// TODO use  "git rev-parse --show-toplevel" for a more reliable way to check if we are in the root of the repo
	entries, err := os.ReadDir(".")
	if err != nil {
		panic(err)
	}
	docker_compose_found := false
	git_dir_found := false
	for _, entry := range entries {
		if entry.Name() == "docker-compose-prod.yaml" {
			docker_compose_found = true
		}
		if entry.Name() == ".git" {
			git_dir_found = true
		}
	}
	return docker_compose_found && git_dir_found
}

func main() {

	if !RunningFromRepoRoot() {
		fmt.Println("You must run this command from the root of the repo. Use 'go run codegen/generate.go'")
		os.Exit(1)
	}

	data, err := os.ReadFile(path.Join("codegen", "sources", "configs.json"))
	if err != nil {
		panic(err)
	}

	configs := []Config{}
	err = json.Unmarshal(data, &configs)
	if err != nil {
		panic(err)
	}
	for _, config := range configs {
		fmt.Printf("Generating code for %v\n", config.Name)
		config.Generate()
	}
}
